# SkipList and HashTable Implementation And Analysis
 BGU Data Structure course 4th assignment. Implementation and analysis of the Skip-List and HashMap Data Structures.

# Introduction
In this assignment, we discuss two main data structures seen in class, with some modifications: The Skip-List and Hash-Table. This assignment includes both practical and theoretical parts. The practical assignment is to be implemented using Java (version 17) using the included [skeleton files](Skeleton). 

This writeup is a cut and nicely organized version of my solution for the assignment, both can be found under [PDFs](PDFs).

# Skip List
A skip list (or skiplist) is a probabilistic data structure that allows O(LOG n) ⁡ average complexity for search as well as O(LOG n) average complexity for insertion within an ordered sequence of n elements.

This skip list is composed of nodes, each of these represents a single value in the data structure, and contains four fields:
- An array of pointers to the previous links, each position correlates to the previous link in the respective level of the skip list.
- An array of pointers to the next links, each position correlates to the next link in the respective level of the skip list.
- A height indicator.
- The value of the node.

Therefore, this implementation consists of several doubly-linked lists, and contains two sentinel nodes.


In the class [AbstractSkipList](Skeleton/AbstractSkipList.java) you are given implementations of the operations:

-  **insert(key)** - Inserts the key key into the DS - Θ(log n) expected.
-  **delete(node)** - Removes the node node from the DS - Θ(1) expected.
-  **search(key)** - Returns the node with key key from the DS if exists, or null otherwise - Θ(log n) expected.
-  **minimum()** - Returns the minimal non −∞ value in the DS - Θ(1) worst-case.
-  **maximum()** - Returns the maximal non +∞ value in the DS - Θ(1) worst-case.
-  **successor(node)** - Returns the successor of the key of the node node from the DS - Θ(1) worst-case.
-  **predecessor(node)** - Returns the predecessor of the key of the node node from the DS - Θ(1) worst-case.
-  **toString** - A basic toString implementation that prints all the values in each level.


## Task 2.1
- **find(key)** - Returns the node of the key key, or the node previous to the supposed location of such a node, if not in the data structure.
- **generateHeight()** - Returns a height generated by the result of a geometric process (defined below) with probability p ∈ (0, 1), where p is a parameter of the data-structure.

**Definition:** The result of a Geometric Process with probability p is the number of coin tosses until the first success ("head") (including), with probability p for success.

**Implement the two functions mentioned above in the class IndexableSkipList given to you.**
- **find(key)**
  
![](Images/2.png)

- **generateHeight()**

![](Images/1.png)


## Task 2.2
- **measureLevels(p, x)** - This function generates x random heights with probability p. It calculates the average number of levels (ˆℓ) described above and returns its value.

**Implement the function measureLevels in SkipListExperimentUtils, and for each p ∈ {0.33, 0.5, 0.75, 0.9} fill in the table**
- **measureLevels(p, x)**
  
![](Images/3.png)

- **Measurement table**
  
![](Images/4.png)


### Task 2.3
**How does the value of p affects the average number of levels (ˆℓi) generated by generateHeight?**

> The higher the probability for success the lower the average number of levels. (P is in inverse proportion to the average height)

### Task 2.4
**How does the value of x effects the average delta generated in each experiment? What can we deduce from that?**
> The larger the sample size (x) we are using the lower the delta we get. This is because over a lot of operations the random elements even out.


### Task 2.5
Now, we want to test the average time for each operation type on the data structure. In the class SkipListExperimentUtils, you are given the skeleton of the following functions:

-  **measureInsertions(p, size)** - This function returns a skip list of size size + 1 and the average time (in nano-seconds) for each insertion in the process as a Pair. The values inserted are the values in {0, 2, 4, . . . , 2 · size} in random order, and the data structure is with the parameter p.
- **measureSearch(DS, size)** - This function returns the average time (in nano-seconds) of a search in the data structure DS of an item from the values in {0, 1, 2, . . . , 2 · size} in random order.
- **measureDeletions(DS, size)** - This function returns the average time (in nano-seconds) for each deletionin the data structure DS of an item from the values in {0, 2, 4, . . . , 2 · size} in random order.
- **main(args)** - This is a standard main function, in which you should perform the experiments.

![](Images/5.png)

After each experiment, we get three measurements: Average Insertion Time; Average Search Time; Average Deletion Time.

Notice that since the order of operations is random, and due to the fact that time measurements on computers tend to be noisy (as explained in Practical Session 1), a single test may return unreliable results. To make our experimentation more reliable, we perform this flow 30 times, and calculate the average of each type of measurement.

That means that each table entry is of the form: 
> Average Measurement = (1 / 30) * sum of all measurements

**Implement the functions given in SkipListExperimentUtils, which includes the main function to perform the experiments described in the next question.**

The code is available [here](Implementation/SkipListExperimentUtils.java).

### Task 2.6
**Fill the table for each p ∈ {0.33, 0.5, 0.75, 0.9} with the average of 30 experiments for each value of x ∈ {1000, 2500, 5000, 10000, 15000, 20000, 50000}**

![](Images/6.png)

![](Images/7.png)

![](Images/8.png)


### Task 2.7
**After you have completed the experiments above, plot (using your favorite method, suchas Microsoft Excel, Google Sheets, Libre Office, etc.) a graph for each operation type (Insertion, Search andDeletion), depicting the average time of operation as a function of x. Each graph should include 4 plot lines -each representing a different value of p.**

- Insertion:

 ![](graphs/Insertion%20graph.PNG)

- Search

![](graphs/Search%20graph.PNG)

- Deletion
  
![](graphs/Delete%20graph.PNG)


### Task 2.8
**Using the graph created above, how does the value of p effects each of the operations?**
> The average insertion time is the lowest when P is around the halfway point between0 and 1. that because when P is too high the generate-height function and thus the linking on each level takesmore time (because there are more levels). And also the find function used in the insert operation take longerdue to the list being higher (that’s because we also need to go down as well as to the right).And if the P value is too low there won’t be enough variety in different nodes’ heights, making the find functionmore and more similar to linear search - thus making it slower.

> Search: The lower the P value, the lower the average search time, up to a certain threshold, due to the samereason as in Insertion.

> Delete: The lower the P, the higher the average deletion time.

### Task 2.9
In questions (2.9) (2.10) (2.11), we will revise the calculation of the expected height/size/Insertion/Search cost, and extend it to any value 0 < p < 1. In your proofs you will show all the mathematical developments done in order to prove your result.

**What is the expected number of nodes in a conceptual Skip-List containing n elements, not including the Sentinels, as a function of p? Prove your answer.**

![](Images/9.png)

### Task 2.10
**What is the expected height of a Skip-List as a function of p? Prove your answer.**

![](Images/10.png)


### Task 2.11
**What is the expected time complexity of Insertion/Search as a function of p? Prove your answer. How does it compare with the empirical results in Question (2.6)?**

![](Images/11.png)
